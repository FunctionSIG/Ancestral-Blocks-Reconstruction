''' Author : Huy Nguyen
    Project: provide method and helper method to find all possible parents
             from 2 given gene_block
             Also calculate the cost for each of the possible parents based
             on a given cost function
    Type   : Genome type is a combination of gene type and a '|' character
             Gene type is string stype
    Start  : 01/07/2016
    End    :
'''

''' @function   : return number of split event from a genome
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: integer
'''
def countSplit(Genome):
    count= 0
    for element in Genome:
        if element == '|':
            count +=1
    return count

''' @function   : return list of genes that are duplicated in a block of gene with the
                  block it appear in
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: list of gene 
'''
def countDup(Genome):
    # splitting Genome into blocks of gene 
    gene_list=Genome.split('|')
    gene_dup=[]
    # iterate through the list of gene blocks
    for index in range(0,len(gene_list)-1):
        # iterate through each gene in a gene block
        for item in range (0, len(gene_list[index])-1):
            # iterate from the index next to our gene (need checking) to the end of the gene block
            for i in range(item, len(gene_list[index])-1):
                if gene_list[index][item] == gene_list[index][i]:
                    gene_dup.append(gene_list[index][item])                    
    return gene_dup

''' @function   : find the initial set of blocks of genes/ genes, and provide dictionary that
                  has key is the gene , and value is the either 1 or 2. 1 means it appear in 1 genome,
                  2 means it appear in both genome
    @para_type  : 2 list of genes , 2 integer number
    @result_type: list of gene, dictionary.
'''
def findSetInitial(Genome1,Genome2,split1,split2):
    # set of initial gene and blocks that will be return
    initial =set()
    # element count is a dictionary
    elementCount= {}
    # set of different gene in Genome1
    Genome1_gene= set()
    for element in Genome1:
        if element != '|':
            Genome1_gene.add(element)
    # set of different gene in Genome2
    Genome2_gene= set()
    for element in Genome2:
        if element != '|':
            Genome2_gene.add(element)

    # union the above 2 set to get list of possible gene from 2 Genome
    union = Genome1_gene.union(Genome2_gene)
    # intersect the above 2 set to get list of gene that appears in both genome
    intersect = Genome1_gene.intersection(Genome2_gene)
    # create a set of element count
    for gene in union:
        # add a list (gene,value) (since set does not take dictionary)
        if gene in intersect:
            elementCount[gene]=2
        else:
            elementCount[gene]=1

    # if neither of them has a split (life is real good)
    if split1 == 0 and split2 == 0:
        initial = union

    # if both of them have split ( grrrr )
    if split1 !=0 and split2 !=0:
        ''' parse the genome1 and genome2 into 2 sets og group of genes
            that is delimitered by |
            ex: ab|cd|ef will be same as ef|cd|ab
            ab|cd|ef will be the same as dc|ba|fe
        '''
        Gene1Blocks = Genome1.split('|')
        Gene2Blocks = Genome2.split('|')
        # sorted before add to make sure 'ab' same as 'ba'
        for element in Gene1Blocks:
            initial.add(''.join(sorted(element))) 
        for element in Gene2Blocks:
            initial.add(''.join(sorted(element)))
        ''' for cases that return set {'abc','bc','a','ef','f'}
            I will remove 'bc', 'a' and 'f' because having 'abc','ef' is 
            representative enough. In addition, the cost of split is the minimum
            (need to be proved)
        '''
        CandidateBlocks=[]
        # make a copy of our initial set into a list to use index'
        for element in initial:
            CandidateBlocks.append(element)
        # clear our initial set, prepare to add those that are not subsets to it'
        initial.clear()
        for index in range(len(CandidateBlocks)):
            add = True # to add the element or not
            for i in range(len(CandidateBlocks)): # 'ab' might appear before 'b'
                if CandidateBlocks[index] in CandidateBlocks[i] and index !=i:
                    add = False
                    break
            if add:
                initial.add(CandidateBlocks[index])
    # if one of them has a split (we can assume second one has split
    # because we can switch from the parameter of our function)
    if split1 ==0 and split2 !=0:
        Gene2Blocks = Genome2.split('|')
        for element in Gene2Blocks:
            initial.add(''.join(sorted(element)))
        CandidateBlocks=[]
        for element in initial:
            CandidateBlocks.append(element)
        #check if the element from gene1 is a subset of any element in
        # element of gene2Blocks
        for element in Genome1:
            add = True
            for geneBlocks in CandidateBlocks:
                if element in geneBlocks:
                    add = False
                    break
            if add:
                initial.add(element)
    return (initial,elementCount)

# Testing

print("Here are test cases for finding the initial parent")
print("There could be many possible parents, the result is just the minimum of such cases")
print()

print("Case: Checking for number of time an element appear, no split")
print("Genome 1: abbcdef")
print("Genome 2: acdghh")
Genome1= 'abbcdef'
Genome2= 'acdghh'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')

print("Case1: Checking block order does not matter, both split")
print("Genome 1: ab|ce|fg")
print("Genome 2: ce|fg|ab")
Genome1= 'ab|ce|fg'
Genome2= 'ce|fg|ab'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')

print("Case2: Checking gene order in a gene block does not matter, both split")
print("Genome 1: ab|ce|fg")
print("Genome 2: ec|ba|gf")
Genome1= 'ab|ce|fg'
Genome2= 'ec|ba|gf'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')

print("Case3: prioritize gene block, both split")
print("Genome 1: abc|de|f")
print("Genome 2: a|bc|de|f")
Genome1= 'abc|de|f'
Genome2= 'a|bc|de|f'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')


print("Case4: no split and split")
print("Genome 1: abcdefg")
print("Genome 2: a|b|c|def")
Genome1= 'abcdefg'
Genome2= 'a|b|c|def'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')

print("Case5: duplication")
print("Genome 1: abb|ccd|e|f|g|k|l")
print("Genome 2: ecd|l|a|g|b")
Genome1= 'abb|ccd|e|f|g|k|l'
Genome2= 'ecd|l|a|g|b'
split1= countSplit(Genome1)
split2= countSplit(Genome2)
print(countDup(Genome1), countDup(Genome2))
print("Result:", findSetInitial(Genome1,Genome2,split1,split2))
print()
print('******************************************************************')
    

   
    
