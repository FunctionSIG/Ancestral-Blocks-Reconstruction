''' Author : Huy Nguyen
    Project: provide method and helper method to find all possible parents
             from 2 given gene_block
             Also calculate the cost for each of the possible parents based
             on a given cost function
    Type   : Genome type is a combination of gene type and a '|' character
             Gene type is string stype
    Start  : 01/07/2016
    End    :
'''

''' @function   : return number of split event from a genome
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: integer
'''
def countSplit(Genome):
    count= 0
    for element in Genome:
        if element == '|':
            count +=1
    return count

''' @function   : return list of genes that are duplicated in a block of gene with the
                  block it appear in
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: list of gene 
'''
def countDup(Genome):
    # splitting Genome into blocks of gene 
    gene_list=Genome.split('|')
    gene_dup=[]
    # iterate through the list of gene blocks
    for index in range(len(gene_list)):
        # iterate through each gene in a gene block
        for item in range (len(gene_list[index])):
            # iterate from the index next to our gene (need checking) to the end of the gene block
            for i in range(item+1, len(gene_list[index])):
                if gene_list[index][item] == gene_list[index][i]:
                    gene_dup.append(gene_list[index][item])                    
    return gene_dup

''' @function   : return set of gene in a Genome
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: set of gene
'''
def setOfGene(Genome):
    Genome_gene= set()
    for gene in Genome:
        if gene != '|':
            Genome_gene.add(gene)
    return Genome_gene

''' @function   : return set of geneblocks/gene in a Genome, given that Genome has split event
    @para_type  : list (this list comprises of genes, and '|' as split event)
    @result_type: set of gene blocks( at least exist 1 gene block)
'''
def setOfBlocks(Genome):
    GeneBlocks = Genome.split('|')
    initial = set()
    # sorted before add to make sure 'ab' same as 'ba'
    for element in GeneBlocks:
        initial.add(''.join(sorted(element)))
    return initial

''' @function   : return list of blocks genes or genes that has no element that is a subset of an
                  element in the set
    @para_type  : set of block of genes/ genes.
    @result_type: list of blocks genes, genes. 
'''
def reductionSubset(initial):
        ''' for cases that return set {'abc','bc','a','ef','f'}
            I will remove 'bc', 'a' and 'f' because having 'abc','ef' is 
            representative enough. In addition, the cost of split is the minimum
            (need to be proved)
        '''
        CandidateBlocks=[]
        # make a copy of our initial set into a list to use index'
        for element in initial:
            CandidateBlocks.append(element)
        # clear our initial set, prepare to add those that are not subsets to it'
        initial.clear()
        for index in range(len(CandidateBlocks)):
            add = True # to add the element or not
            for i in range(len(CandidateBlocks)): # 'ab' might appear before 'b'
                if CandidateBlocks[index] in CandidateBlocks[i] and index !=i:
                    add = False
                    break
            if add:
                initial.add(CandidateBlocks[index])
        return initial
    
''' @function   : return list of blocks genes or genes that for each block of genes, the gene
                  in the block has count of 2.
    @para_type  : set of block of genes/ genes.
    @result_type: list of blocks genes/ genes 
'''
def reductionCount(initial, dic):
    result= set()
    for element in initial:
        if len(element) ==1:
            result.add(element)
            continue
        else:
            copy=''
            for gene in element:
                if dic[gene] ==2:
                    copy +=gene
            result.add(copy)
    return result
            
                    
    
''' @function   : find the initial set of blocks of genes/ genes, and provide dictionary that
                  has key is the gene , and value is the either 1 or 2. 1 means it appear in 1 genome,
                  2 means it appear in both genome
    @para_type  : 2 list of genes , 2 integer number
    @result_type: list of gene, dictionary.
'''
def findSetInitial_Genome(Genome1,Genome2,split1,split2):
    # set of initial gene and blocks that will be return
    initial =set()
    # element count is a dictionary
    elementCount= {}
    # set of different gene in Genome1
    Genome1_gene= setOfGene(Genome1)
    # set of different gene in Genome2
    Genome2_gene= setOfGene(Genome2)

    # union the above 2 set to get list of possible gene from 2 Genome
    union = Genome1_gene.union(Genome2_gene)
    # intersect the above 2 set to get list of gene that appears in both genome
    intersect = Genome1_gene.intersection(Genome2_gene)
    # create a set of element count
    for gene in union:
        # add a list (gene,value) (since set does not take dictionary)
        if gene in intersect:
            elementCount[gene]=2
        else:
            elementCount[gene]=1

    ### if neither of them has a split (life is real good)
    if split1 == 0 and split2 == 0:
        initial = union

    ### if both of them have split ( grrrr )
    if split1 !=0 and split2 !=0:
        ''' parse the genome1 and genome2 into 2 sets og group of genes
            that is delimitered by |
            ex: ab|cd|ef will be same as ef|cd|ab
            ab|cd|ef will be the same as dc|ba|fe
        '''
        # add the set of gene blocks from genome1
        initial.update(setOfBlocks(Genome1))
        # add the set of gene blocks from genome2
        initial.update(setOfBlocks(Genome2))
        # reduce by the count
        initial = reductionCount(initial, elementCount)
        # reduce the subset
        initial = reductionSubset(initial)
        
    # if one of them has a split (we can assume second one has split
    # because we can switch from the parameter of our function)
    if split1 ==0 and split2 !=0:
        # add the set of gene blocks from genome2
        initial.update(setOfBlocks(Genome2))
        # add element that is in genome1 but not 2
        initial=initial.union(Genome1_gene)
        # reduce by the count
        initial = reductionCount(initial, elementCount)
        # reduce the subset
        initial = reductionSubset(initial)
    return (initial,elementCount)
